---

# ğŸ§  Project Snapshot â€” Greko VRM Engine v3.3

---

> **TL;DR:** Morph targets are now fully stable and hot-swappable at runtime. The engine supports real-time phoneme injection without mesh corruption, spikes, or GPU reallocation. Greko has evolved from a renderer into a real-time facial animation engine.

---

## ğŸ—ï¸ The Evolution: From Geometry to Expression

V3.0 proved we could render VRM models correctly.

V3.1 proves we can control their faces at runtime.

This phase focused entirely on solving:

* Morph buffer corruption
* Vertex explosions (â€œThe Spike Catastropheâ€)
* Runtime blendshape replacement
* Multi-system morph coexistence (Blink + Breath + Mouth)

The goal was simple: **stable real-time facial control on low-end hardware.**

---

## ğŸ’¥ The Morph Spike Crisis

### The Problem

When swapping morph targets dynamically:

* Vertices exploded outward
* Mesh distorted unpredictably
* Some frames rendered correctly, others broke

This made runtime phoneme switching unreliable and visually catastrophic.

---

### Root Causes Identified

1. Incorrect VAO binding during VBO updates
2. Attribute stride mismatches
3. GPU buffer reallocation via `glBufferData`
4. Morph slot indexing inconsistencies
5. Shader weight set to `0.0` (morph data uploaded but invisible)

The engine was technically updating morph buffers â€” but the pipeline was unstable.

---

## ğŸ”§ The Breakthrough: Stable Hot-Swapping

The core fix was replacing buffer reallocation with sub-data updates:

Instead of:

`glBufferData(...)`

We now use:

`glBufferSubData(GL_ARRAY_BUFFER, 0, size, new_data);`

---

### Why This Changed Everything

* No memory reallocation
* No VAO invalidation
* No GPU fragmentation
* No vertex spikes
* Sub-millisecond morph updates

This was the moment morphs became deterministic and stable.

---

## ğŸ§¬ Final Morph Architecture

Each mesh now maintains **4 dedicated morph slots**, each mapped to a shader weight channel.

| Slot | Purpose   | Shader Weight |
| ---- | --------- | ------------- |
| 0    | Blink     | weight.x      |
| 1    | Breathing | weight.y      |
| 2    | Phoneme   | weight.z      |
| 3    | Reserved  | weight.w      |

---

### Vertex Shader Composition

Final vertex position is computed as:

base

* morph0 Ã— weight.x
* morph1 Ã— weight.y
* morph2 Ã— weight.z
* morph3 Ã— weight.w

This guarantees deterministic layering of expressions and prevents behavior interference.

---

## ğŸ‘„ MouthSequencer System

### Objective

Inject VRM phoneme blendshapes at runtime:

* Fcl_MTH_A
* Fcl_MTH_E
* Fcl_MTH_I
* Fcl_MTH_O
* Fcl_MTH_U

---

### Runtime Flow

1. Python parses morph delta data from GLB.
2. NumPy stores raw float buffers.
3. `pybind11` passes raw memory pointers to C++ (zero-copy).
4. C++ updates Morph Slot 2 using `glBufferSubData`.
5. `uMorphWeights.z` activates the phoneme in the shader.

---

### Result

* Real-time phoneme switching
* No GPU reinitialization
* No mesh corruption
* No frame instability
* Stable at 70â€“120 FPS

---

## ğŸ§  Unified Morph Weight Control

A critical discovery:

> Updating morph vertex data is meaningless if the shader weight is zero.

Solution: Centralized morph weight management in Python.

Example logic:

Blink â†’ weight.x
Breath â†’ weight.y
Mouth â†’ weight.z

All weights are set together per frame, preventing:

* Behavior overwrites
* Silent morph suppression
* Expression conflicts

This ensures clean multi-system coexistence.

---

## ğŸ“ˆ Performance Benchmarks

Test Hardware: GT 710 (Low-end GPU)

* FPS: 70â€“120 stable
* Vertex Spikes: None
* Memory Leaks: None
* Buffer Reallocations During Morph Swap: Zero
* Runtime Stability: Verified

Morph hot-swapping has negligible performance overhead.

---

## ğŸ§  Behavior System Status

The modular behavior injection system is fully operational:

* Dynamic Python behavior loading
* Face index injection
* Library injection
* Dedicated morph slot assignment
* Runtime-safe buffer updates

Active behaviors:

* Blink
* Breath
* MouthSequencer (Phonemes)

All run simultaneously without mesh corruption.

---

## ğŸ§ª Engine State â€” â€œExpression Phaseâ€

* Geometry: Stable
* Skinning: Stable
* Morph Targets: Stable
* Runtime Updates: Stable
* Phoneme Switching: Stable
* Performance: Verified

Greko is no longer just a renderer.

It is now a **real-time facial animation system built from scratch.**

---

## ğŸ› ï¸ Technical Stack

* OpenGL 4.3 Core
* GLFW3
* GLM (Matrix math: MVP = P Ã— V Ã— M)
* pybind11 (Zero-copy Python â†” C++ bridge)
* NumPy raw memory buffers
* Custom GLB/VRM parser (Python-side)

No Assimp.
No Panda3D.
No morph stripping.
No engine black boxes.

---

## ğŸ Milestone Conclusion

V3.3 marks the moment Greko achieved full control over the facial pipeline.

Direct GPU authority.
Deterministic morph layering.
Runtime-stable phoneme injection.
Low-end hardware compatibility.

Greko has entered the **Expression Era**.

---

â¬…ï¸ [Back to Snapshots Menu](./README.md)
